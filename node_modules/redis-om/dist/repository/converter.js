"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonConverter = exports.HashConverter = void 0;
class AbstractConverter {
    constructor(schemaDef) {
        this.schemaDef = schemaDef;
    }
}
class HashConverter extends AbstractConverter {
    toHashData(entityData) {
        let hashData = {};
        for (let fieldName in this.schemaDef) {
            let entityValue = entityData[fieldName];
            let fieldDef = this.schemaDef[fieldName];
            let fieldType = fieldDef.type;
            if (entityValue !== undefined)
                hashData[fieldName] = toHashConverters[fieldType](entityValue, fieldDef);
        }
        return hashData;
    }
    toEntityData(hashData) {
        let entityData = {};
        for (let fieldName in this.schemaDef) {
            let hashValue = hashData[fieldName];
            let fieldDef = this.schemaDef[fieldName];
            let fieldType = fieldDef.type;
            if (hashValue !== undefined)
                entityData[fieldName] = fromHashConverters[fieldType](hashValue, fieldDef);
        }
        return entityData;
    }
}
exports.HashConverter = HashConverter;
class JsonConverter extends AbstractConverter {
    toJsonData(entityData) {
        let jsonData = {};
        for (let fieldName in this.schemaDef) {
            let fieldValue = entityData[fieldName];
            let fieldDef = this.schemaDef[fieldName];
            let fieldType = fieldDef.type;
            if (fieldValue !== undefined)
                jsonData[fieldName] = toJsonConverters[fieldType](fieldValue);
        }
        return jsonData;
    }
    toEntityData(jsonData) {
        let entityData = {};
        if (jsonData === null)
            return entityData;
        for (let fieldName in this.schemaDef) {
            let jsonValue = jsonData[fieldName];
            let fieldDef = this.schemaDef[fieldName];
            let fieldType = fieldDef.type;
            if (jsonValue !== undefined && jsonValue !== null)
                entityData[fieldName] = fromJsonConverters[fieldType](jsonValue);
        }
        return entityData;
    }
}
exports.JsonConverter = JsonConverter;
let toHashConverters = {
    'number': (value) => value.toString(),
    'boolean': (value) => value ? '1' : '0',
    'string': (value) => value.toString(),
    'text': (value) => value.toString(),
    'point': (value) => pointToString(value),
    'date': (value) => dateToString(value),
    'string[]': (value, fieldDef) => stringArrayToString(value, fieldDef)
};
let fromHashConverters = {
    'number': stringToNumber,
    'boolean': stringToBoolean,
    'string': (value) => value,
    'text': (value) => value,
    'point': stringToPoint,
    'date': stringToDate,
    'string[]': (value, fieldDef) => stringToStringArray(value, fieldDef)
};
let toJsonConverters = {
    'number': (value) => value,
    'boolean': (value) => value,
    'string': (value) => value,
    'text': (value) => value,
    'point': (value) => pointToString(value),
    'date': (value) => dateToNumber(value),
    'string[]': (value) => value
};
let fromJsonConverters = {
    'number': (value) => value,
    'boolean': (value) => value,
    'string': (value) => value,
    'text': (value) => value,
    'point': (value) => stringToPoint(value),
    'date': (value) => numberToDate(value),
    'string[]': (value) => value
};
function pointToString(value) {
    let { longitude, latitude } = value;
    return `${longitude},${latitude}`;
}
function dateToString(value) {
    return value.getTime().toString();
}
function dateToNumber(value) {
    return value.getTime();
}
function stringArrayToString(value, fieldDef) {
    var _a;
    return value.join((_a = fieldDef.separator) !== null && _a !== void 0 ? _a : '|');
}
function stringToNumber(value) {
    let number = Number.parseFloat(value);
    if (Number.isNaN(number) === false)
        return number;
    throw Error(`Non-numeric value of '${value}' read from Redis for number field.`);
}
function stringToBoolean(value) {
    if (value === '0')
        return false;
    if (value === '1')
        return true;
    throw Error(`Non-boolean value of '${value}' read from Redis for boolean field.`);
}
function stringToPoint(value) {
    let [longitude, latitude] = value.split(',').map(Number.parseFloat);
    return { longitude, latitude };
}
function stringToDate(value) {
    let parsed = Number.parseInt(value);
    if (Number.isNaN(parsed))
        throw Error(`Non-numeric value of '${value}' read from Redis for date field.`);
    let date = new Date();
    date.setTime(parsed);
    return date;
}
function stringToStringArray(value, fieldDef) {
    var _a;
    return value.split((_a = fieldDef.separator) !== null && _a !== void 0 ? _a : '|');
}
function numberToDate(value) {
    let date = new Date();
    date.setTime(value);
    return date;
}
