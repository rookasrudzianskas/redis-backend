"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonRepository = exports.HashRepository = void 0;
const search_1 = require("../search/search");
const converter_1 = require("./converter");
class Repository {
    constructor(schema, client) {
        this.schema = schema;
        this.client = client;
    }
    async createIndex() {
        let currentIndexHash = await this.client.get(this.schema.indexHashName);
        if (currentIndexHash !== this.schema.indexHash) {
            await this.dropIndex();
            let options = {
                indexName: this.schema.indexName,
                dataStructure: this.schema.dataStructure,
                prefix: `${this.schema.prefix}:`,
                schema: this.schema.redisSchema
            };
            if (this.schema.useStopWords === 'OFF')
                options.stopWords = [];
            if (this.schema.useStopWords === 'CUSTOM')
                options.stopWords = this.schema.stopWords;
            await this.client.createIndex(options);
            await this.client.set(this.schema.indexHashName, this.schema.indexHash);
        }
    }
    async dropIndex() {
        try {
            await this.client.unlink(this.schema.indexHashName);
            await this.client.dropIndex(this.schema.indexName);
        }
        catch (e) {
            if (e instanceof Error && e.message === "Unknown Index name") {
            }
            else {
                throw e;
            }
        }
    }
    createEntity(data = {}) {
        let id = this.schema.generateId();
        let entity = new this.schema.entityCtor(this.schema, id);
        for (let key in data) {
            if (this.schema.entityCtor.prototype.hasOwnProperty(key)) {
                entity[key] = data[key];
            }
        }
        return entity;
    }
    async save(entity) {
        let key = this.makeKey(entity.entityId);
        if (Object.keys(entity.entityData).length === 0) {
            await this.client.unlink(key);
        }
        else {
            await this.writeEntity(key, entity.entityData);
        }
        return entity.entityId;
    }
    async createAndSave(data = {}) {
        let entity = this.createEntity(data);
        await this.save(entity);
        return entity;
    }
    async fetch(id) {
        let key = this.makeKey(id);
        let entityData = await this.readEntity(key);
        return new this.schema.entityCtor(this.schema, id, entityData);
    }
    async remove(id) {
        let key = this.makeKey(id);
        await this.client.unlink(key);
    }
    async expire(id, ttlInSeconds) {
        let key = this.makeKey(id);
        await this.client.expire(key, ttlInSeconds);
    }
    search() {
        return new search_1.Search(this.schema, this.client);
    }
    searchRaw(query) {
        return new search_1.RawSearch(this.schema, this.client, query);
    }
    makeKey(id) {
        return `${this.schema.prefix}:${id}`;
    }
}
exports.default = Repository;
class HashRepository extends Repository {
    constructor(schema, client) {
        super(schema, client);
        this.converter = new converter_1.HashConverter(schema.definition);
    }
    async writeEntity(key, data) {
        let hashData = this.converter.toHashData(data);
        await this.client.hsetall(key, hashData);
    }
    async readEntity(key) {
        let hashData = await this.client.hgetall(key);
        return this.converter.toEntityData(hashData);
    }
}
exports.HashRepository = HashRepository;
class JsonRepository extends Repository {
    constructor(schema, client) {
        super(schema, client);
        this.converter = new converter_1.JsonConverter(schema.definition);
    }
    async writeEntity(key, data) {
        let jsonData = this.converter.toJsonData(data);
        await this.client.jsonset(key, jsonData);
    }
    async readEntity(key) {
        let jsonData = await this.client.jsonget(key);
        return this.converter.toEntityData(jsonData);
    }
}
exports.JsonRepository = JsonRepository;
