"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Search = exports.RawSearch = exports.AbstractSearch = void 0;
const logger = __importStar(require("../shims/logger"));
const where_and_1 = __importDefault(require("./where-and"));
const where_or_1 = __importDefault(require("./where-or"));
const where_string_array_1 = __importDefault(require("./where-string-array"));
const where_boolean_1 = require("./where-boolean");
const where_number_1 = __importDefault(require("./where-number"));
const where_point_1 = __importDefault(require("./where-point"));
const where_string_1 = __importDefault(require("./where-string"));
const where_text_1 = __importDefault(require("./where-text"));
const results_converter_1 = require("./results-converter");
const __1 = require("..");
const where_date_1 = __importDefault(require("./where-date"));
class AbstractSearch {
    constructor(schema, client) {
        this.schema = schema;
        this.client = client;
    }
    sortAscending(field) {
        return this.sortBy(field, 'ASC');
    }
    sortDesc(field) {
        return this.sortDescending(field);
    }
    sortDescending(field) {
        return this.sortBy(field, 'DESC');
    }
    sortAsc(field) {
        return this.sortAscending(field);
    }
    sortBy(field, order = 'ASC') {
        let fieldDef = this.schema.definition[field];
        let dataStructure = this.schema.dataStructure;
        if (fieldDef === undefined) {
            let message = `'sortBy' was called on field '${field}' which is not defined in the Schema.`;
            logger.error(message);
            throw new __1.RedisError(message);
        }
        let type = fieldDef.type;
        let markedSortable = fieldDef.sortable;
        const UNSORTABLE = ['point', 'string[]'];
        const JSON_SORTABLE = ['number', 'text', 'date'];
        const HASH_SORTABLE = ['string', 'boolean', 'number', 'text', 'date'];
        if (UNSORTABLE.includes(type)) {
            let message = `'sortBy' was called on '${type}' field '${field}' which cannot be sorted.`;
            logger.error(message);
            throw new __1.RedisError(message);
        }
        if (dataStructure === 'JSON' && JSON_SORTABLE.includes(type) && !markedSortable)
            logger.warn(`'sortBy' was called on field '${field}' which is not marked as sortable in the Schema. This may result is slower searches. If possible, mark the field as sortable in the Schema.`);
        if (dataStructure === 'HASH' && HASH_SORTABLE.includes(type) && !markedSortable)
            logger.warn(`'sortBy' was called on field '${field}' which is not marked as sortable in the Schema. This may result is slower searches. If possible, mark the field as sortable in the Schema.`);
        this.sort = { field, order };
        return this;
    }
    async min(field) {
        return await this.sortBy(field, 'ASC').first();
    }
    async max(field) {
        return await this.sortBy(field, 'DESC').first();
    }
    async count() {
        let searchResults = await this.callSearch();
        return this.schema.dataStructure === 'JSON'
            ? new results_converter_1.JsonSearchResultsConverter(this.schema, searchResults).count
            : new results_converter_1.HashSearchResultsConverter(this.schema, searchResults).count;
    }
    async page(offset, count) {
        let searchResults = await this.callSearch({ offset, count });
        return this.schema.dataStructure === 'JSON'
            ? new results_converter_1.JsonSearchResultsConverter(this.schema, searchResults).entities
            : new results_converter_1.HashSearchResultsConverter(this.schema, searchResults).entities;
    }
    async first() {
        var _a;
        let foundEntity = await this.page(0, 1);
        return (_a = foundEntity[0]) !== null && _a !== void 0 ? _a : null;
    }
    async all(options = { pageSize: 10 }) {
        let entities = [];
        let offset = 0;
        let pageSize = options.pageSize;
        while (true) {
            let foundEntities = await this.page(offset, pageSize);
            entities.push(...foundEntities);
            if (foundEntities.length < pageSize)
                break;
            offset += pageSize;
        }
        return entities;
    }
    get return() {
        return this;
    }
    async returnMin(field) {
        return await this.min(field);
    }
    async returnMax(field) {
        return await this.max(field);
    }
    async returnCount() {
        return await this.count();
    }
    async returnPage(offset, count) {
        return await this.page(offset, count);
    }
    async returnAll(options = { pageSize: 10 }) {
        return await this.all(options);
    }
    async returnFirst() {
        return await this.first();
    }
    async callSearch(limit = { offset: 0, count: 0 }) {
        let options = {
            indexName: this.schema.indexName,
            query: this.query,
            limit
        };
        if (this.sort !== undefined)
            options.sort = this.sort;
        let searchResults;
        try {
            searchResults = await this.client.search(options);
        }
        catch (error) {
            let message = error.message;
            if (message.startsWith("Syntax error")) {
                throw new __1.RedisError(`The query to RediSearch had a syntax error: "${message}".\nThis is often the result of using a stop word in the query. Either change the query to not use a stop word or change the stop words in the schema definition. You can check the RediSearch source for the default stop words at: https://github.com/RediSearch/RediSearch/blob/master/src/stopwords.h.`);
            }
            throw error;
        }
        return searchResults;
    }
}
exports.AbstractSearch = AbstractSearch;
class RawSearch extends AbstractSearch {
    constructor(schema, client, query = '*') {
        super(schema, client);
        this.rawQuery = query;
    }
    get query() {
        return this.rawQuery;
    }
}
exports.RawSearch = RawSearch;
class Search extends AbstractSearch {
    get query() {
        if (this.rootWhere === undefined)
            return '*';
        return `${this.rootWhere.toString()}`;
    }
    where(fieldOrFn) {
        return this.anyWhere(where_and_1.default, fieldOrFn);
    }
    and(fieldOrFn) {
        return this.anyWhere(where_and_1.default, fieldOrFn);
    }
    or(fieldOrFn) {
        return this.anyWhere(where_or_1.default, fieldOrFn);
    }
    anyWhere(ctor, fieldOrFn) {
        if (typeof fieldOrFn === 'string') {
            return this.anyWhereForField(ctor, fieldOrFn);
        }
        else {
            return this.anyWhereForFunction(ctor, fieldOrFn);
        }
    }
    anyWhereForField(ctor, field) {
        let where = this.createWhere(field);
        if (this.rootWhere === undefined) {
            this.rootWhere = where;
        }
        else {
            this.rootWhere = new ctor(this.rootWhere, where);
        }
        return where;
    }
    anyWhereForFunction(ctor, subSearchFn) {
        let search = new Search(this.schema, this.client);
        let subSearch = subSearchFn(search);
        if (subSearch.rootWhere === undefined) {
            throw new Error("Sub-search without and root where was somehow defined.");
        }
        else {
            if (this.rootWhere === undefined) {
                this.rootWhere = subSearch.rootWhere;
            }
            else {
                this.rootWhere = new ctor(this.rootWhere, subSearch.rootWhere);
            }
        }
        return this;
    }
    createWhere(field) {
        let fieldDef = this.schema.definition[field];
        if (fieldDef === undefined)
            throw new Error(`The field '${field}' is not part of the schema.`);
        if (fieldDef.type === 'boolean' && this.schema.dataStructure === 'HASH')
            return new where_boolean_1.WhereHashBoolean(this, field);
        if (fieldDef.type === 'boolean' && this.schema.dataStructure === 'JSON')
            return new where_boolean_1.WhereJsonBoolean(this, field);
        if (fieldDef.type === 'date')
            return new where_date_1.default(this, field);
        if (fieldDef.type === 'number')
            return new where_number_1.default(this, field);
        if (fieldDef.type === 'point')
            return new where_point_1.default(this, field);
        if (fieldDef.type === 'text')
            return new where_text_1.default(this, field);
        if (fieldDef.type === 'string')
            return new where_string_1.default(this, field);
        if (fieldDef.type === 'string[]')
            return new where_string_array_1.default(this, field);
        throw new Error(`The field type of '${fieldDef.type}' is not a valid field type. Valid types include 'boolean', 'date', 'number', 'point', 'string', and 'string[]'.`);
    }
}
exports.Search = Search;
