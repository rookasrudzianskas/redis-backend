"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const ulid_1 = require("ulid");
const __1 = require("..");
const schema_builder_1 = __importDefault(require("./schema-builder"));
class Schema {
    constructor(ctor, schemaDef, options) {
        this.entityCtor = ctor;
        this.definition = schemaDef;
        this.options = options;
        this.validateOptions();
        this.defineProperties();
    }
    get prefix() { var _a, _b; return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.prefix) !== null && _b !== void 0 ? _b : this.entityCtor.name; }
    get indexName() { var _a, _b; return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.indexName) !== null && _b !== void 0 ? _b : `${this.prefix}:index`; }
    get indexHashName() { var _a, _b; return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.indexHashName) !== null && _b !== void 0 ? _b : `${this.prefix}:index:hash`; }
    get dataStructure() { var _a, _b; return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.dataStructure) !== null && _b !== void 0 ? _b : 'JSON'; }
    get useStopWords() { var _a, _b; return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.useStopWords) !== null && _b !== void 0 ? _b : 'DEFAULT'; }
    get stopWords() { var _a, _b; return (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.stopWords) !== null && _b !== void 0 ? _b : []; }
    get indexHash() {
        let data = JSON.stringify({
            definition: this.definition,
            prefix: this.prefix,
            indexName: this.indexName,
            indexHashName: this.indexHashName,
            dataStructure: this.dataStructure,
            useStopWords: this.useStopWords,
            stopWords: this.stopWords,
        });
        return (0, crypto_1.createHash)('sha1').update(data).digest('base64');
    }
    get redisSchema() { return new schema_builder_1.default(this).redisSchema; }
    generateId() {
        var _a, _b;
        let ulidStrategy = () => (0, ulid_1.ulid)();
        return ((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.idStrategy) !== null && _b !== void 0 ? _b : ulidStrategy)();
    }
    defineProperties() {
        var _a;
        let entityName = this.entityCtor.name;
        for (let field in this.definition) {
            this.validateFieldDef(field);
            let fieldDef = this.definition[field];
            let fieldType = fieldDef.type;
            let fieldAlias = (_a = fieldDef.alias) !== null && _a !== void 0 ? _a : field;
            Object.defineProperty(this.entityCtor.prototype, field, {
                configurable: true,
                get: function () {
                    var _a;
                    return (_a = this.entityData[fieldAlias]) !== null && _a !== void 0 ? _a : null;
                },
                set: function (value) {
                    if (value === undefined) {
                        throw Error(`Property '${field}' on entity of type '${entityName}' cannot be set to undefined. Use null instead.`);
                    }
                    if (value === null) {
                        delete this.entityData[fieldAlias];
                        return;
                    }
                    if (fieldType === 'string' && isStringable(value)) {
                        this.entityData[fieldAlias] = value.toString();
                        return;
                    }
                    if (fieldType === 'text' && isStringable(value)) {
                        this.entityData[fieldAlias] = value.toString();
                        return;
                    }
                    if (fieldType === 'number' && isNumber(value)) {
                        this.entityData[fieldAlias] = value;
                        return;
                    }
                    if (fieldType === 'boolean' && isBoolean(value)) {
                        this.entityData[fieldAlias] = value;
                        return;
                    }
                    if (fieldType === 'point' && isPoint(value)) {
                        let { longitude, latitude } = value;
                        this.entityData[fieldAlias] = { longitude, latitude };
                        return;
                    }
                    if (fieldType === 'date' && isDateable(value) && isDate(value)) {
                        this.entityData[fieldAlias] = value;
                        return;
                    }
                    if (fieldType === 'date' && isDateable(value) && isString(value)) {
                        this.entityData[fieldAlias] = new Date(value);
                        return;
                    }
                    if (fieldType === 'date' && isDateable(value) && isNumber(value)) {
                        let date = new Date();
                        date.setTime(value);
                        this.entityData[fieldAlias] = date;
                        return;
                    }
                    if (fieldType === 'string[]' && isArray(value)) {
                        this.entityData[fieldAlias] = value.map((v) => v.toString());
                        return;
                    }
                    throw new __1.RedisError(`Property '${field}' expected type of '${fieldType}' but received value of '${value}'.`);
                }
            });
            function isStringable(value) {
                return isString(value) || isNumber(value) || isBoolean(value);
            }
            function isDateable(value) {
                return isDate(value) || isString(value) || isNumber(value);
            }
            function isPoint(value) {
                return isNumber(value.longitude) && isNumber(value.latitude);
            }
            function isString(value) {
                return typeof (value) === 'string';
            }
            function isNumber(value) {
                return typeof (value) === 'number';
            }
            function isBoolean(value) {
                return typeof (value) === 'boolean';
            }
            function isDate(value) {
                return value instanceof Date;
            }
            function isArray(value) {
                return Array.isArray(value);
            }
        }
    }
    validateOptions() {
        var _a;
        if (!['HASH', 'JSON'].includes(this.dataStructure))
            throw Error(`'${this.dataStructure}' in an invalid data structure. Valid data structures are 'HASH' and 'JSON'.`);
        if (!['OFF', 'DEFAULT', 'CUSTOM'].includes(this.useStopWords))
            throw Error(`'${this.useStopWords}' in an invalid value for stop words. Valid values are 'OFF', 'DEFAULT', and 'CUSTOM'.`);
        if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.idStrategy) && !(this.options.idStrategy instanceof Function))
            throw Error("ID strategy must be a function that takes no arguments and returns a string.");
        if (this.prefix === '')
            throw Error(`Prefix must be a non-empty string.`);
        if (this.indexName === '')
            throw Error(`Index name must be a non-empty string.`);
    }
    validateFieldDef(field) {
        let fieldDef = this.definition[field];
        if (!['boolean', 'date', 'number', 'point', 'string', 'string[]', 'text'].includes(fieldDef.type))
            throw Error(`The field '${field}' is configured with a type of '${fieldDef.type}'. Valid types include 'boolean', 'date', 'number', 'point', 'string', 'string[]', and 'text'.`);
    }
}
exports.default = Schema;
