"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger = __importStar(require("../shims/logger"));
class SchemaBuilder {
    constructor(schema) {
        this.schema = schema;
    }
    get redisSchema() {
        if (this.schema.dataStructure === 'JSON')
            return this.buildJsonSchema();
        if (this.schema.dataStructure === 'HASH')
            return this.buildHashSchema();
        throw Error(`'${this.schema.dataStructure}' in an invalid data structure. Valid data structures are 'HASH' and 'JSON'.`);
    }
    buildHashSchema() {
        let redisSchema = [];
        for (let field in this.schema.definition) {
            redisSchema.push(...this.buildHashSchemaEntry(field));
        }
        return redisSchema;
    }
    buildJsonSchema() {
        let redisSchema = [];
        for (let field in this.schema.definition) {
            redisSchema.push(...this.buildJsonSchemaEntry(field));
        }
        return redisSchema;
    }
    buildHashSchemaEntry(field) {
        var _a;
        let fieldDef = this.schema.definition[field];
        let fieldType = fieldDef.type;
        let fieldAlias = (_a = fieldDef.alias) !== null && _a !== void 0 ? _a : field;
        let fieldDetails;
        switch (fieldType) {
            case 'date':
                fieldDetails = this.buildSortableNumeric(fieldDef);
                break;
            case 'boolean':
                fieldDetails = this.buildSortableTag(fieldDef);
                break;
            case 'number':
                fieldDetails = this.buildSortableNumeric(fieldDef);
                break;
            case 'point':
                fieldDetails = this.buildGeo();
                break;
            case 'string[]':
                fieldDetails = this.buildSeparableTag(fieldDef);
                break;
            case 'string':
                fieldDetails = this.buildSeparableAndSortableTag(fieldDef);
                break;
            case 'text':
                fieldDetails = this.buildSortableText(fieldDef);
                break;
        }
        ;
        return [fieldAlias, ...fieldDetails];
    }
    buildJsonSchemaEntry(field) {
        var _a;
        let fieldDef = this.schema.definition[field];
        let fieldType = fieldDef.type;
        let fieldAlias = (_a = fieldDef.alias) !== null && _a !== void 0 ? _a : field;
        let fieldPath = `\$.${fieldAlias}${fieldType === 'string[]' ? '[*]' : ''}`;
        let fieldDetails;
        switch (fieldType) {
            case 'date':
                fieldDetails = this.buildSortableNumeric(fieldDef);
                break;
            case 'boolean':
                if (fieldDef.sortable)
                    logger.warn(`You have marked the boolean field '${field}' as sortable but RediSearch doesn't support the SORTABLE argument on a TAG for JSON. Ignored.`);
                fieldDetails = this.buildTag();
                break;
            case 'number':
                fieldDetails = this.buildSortableNumeric(fieldDef);
                break;
            case 'point':
                fieldDetails = this.buildGeo();
                break;
            case 'string[]':
                fieldDetails = this.buildTag();
                break;
            case 'string':
                if (fieldDef.sortable)
                    logger.warn(`You have marked the string field '${field}' as sortable but RediSearch doesn't support the SORTABLE argument on a TAG for JSON. Ignored.`);
                fieldDetails = this.buildSeparableTag(fieldDef);
                break;
            case 'text':
                fieldDetails = this.buildSortableText(fieldDef);
                break;
        }
        return [fieldPath, 'AS', fieldAlias, ...fieldDetails];
    }
    buildSortableNumeric(fieldDef) {
        return this.buildSortableField('NUMERIC', fieldDef.sortable);
    }
    buildTag() {
        return this.buildField('TAG');
    }
    buildSortableTag(fieldDef) {
        return this.buildSortableField('TAG', fieldDef.sortable);
    }
    buildSeparableTag(fieldDef) {
        return this.buildSeparableField('TAG', fieldDef.separator);
    }
    buildSeparableAndSortableTag(fieldDef) {
        return this.buildSeparableAndSortableField('TAG', fieldDef.separator, fieldDef.sortable);
    }
    buildSortableText(fieldDef) {
        return this.buildSortableField('TEXT', fieldDef.sortable);
    }
    buildGeo() {
        return this.buildField('GEO');
    }
    buildField(type) {
        return [type];
    }
    buildSeparableField(type, separator) {
        return [type, 'SEPARATOR', separator !== null && separator !== void 0 ? separator : '|'];
    }
    buildSortableField(type, sortable) {
        return sortable ? [type, 'SORTABLE'] : [type];
    }
    buildSeparableAndSortableField(type, separator, sortable) {
        let result = [type, 'SEPARATOR', separator !== null && separator !== void 0 ? separator : '|'];
        if (sortable)
            result.push('SORTABLE');
        return result;
    }
}
exports.default = SchemaBuilder;
